"use strict";(self.webpackChunkpyjun01_blog=self.webpackChunkpyjun01_blog||[]).push([[299],{6335:function(e,n,t){t.r(n),t.d(n,{default:function(){return b}});var l=t(6540),c=t(8453);function a(e){const n=Object.assign({blockquote:"blockquote",p:"p",a:"a",h1:"h1",code:"code",em:"em",strong:"strong",ol:"ol",li:"li",h2:"h2",pre:"pre",ul:"ul"},(0,c.RP)(),e.components),{TableOfContents:t,Tweet:a,CodeSandbox:r}=n;return r||o("CodeSandbox",!0),t||o("TableOfContents",!0),a||o("Tweet",!0),l.createElement(l.Fragment,null,l.createElement(t),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"해당 글은 Million.js v2.3.2을 기준으로 작성되었습니다"),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.a,{href:"https://twitter.com/aidenybai/status/1647005716350406656?ck_subscriber_id=887762731"},"Million.js 제작자의 트윗"),"을 우연히 보게 되었는데 React 환경에서 성능 최적화를 이끌어내는 방식이 흥미로워서 파헤쳐 보았다."),"\n",l.createElement(a,{tweetLink:"https://twitter.com/aidenybai/status/1647005716350406656",hideConversation:!0}),"\n",l.createElement(n.h1,null,"Million.js는 무엇인가"),"\n",l.createElement(n.p,null,"Million.js는 단순히 React Component를 HOC(",l.createElement(n.a,{href:"https://ko.legacy.reactjs.org/docs/higher-order-components.html"},"Higher Order Component"),")로 감싸는 것만으로도 렌더링 속도를 빠르게 만들어 주는 virtual DOM 라이브러리이다. 어떻게 개선하는지가 재밌는데 뒤에서 자세히 기술하겠지만 react reconciliation 대신 자체 제작한 virtual DOM을 사용해 조작하는 식으로 개선하였다."),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"(Million.js Documentation > Introduction)"),"\n",l.createElement(n.p,null,"Million is an extremely fast and lightweight (",l.createElement(n.code,null,"<4kb"),") virtual DOM that makes ",l.createElement(n.a,{href:"https://reactjs.org/"},"React components")," up to ",l.createElement(n.em,null,l.createElement(n.strong,null,l.createElement(n.a,{href:"https://krausest.github.io/js-framework-benchmark/current.html"},"70% faster")))),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"Oh man... Another /virtual dom|javascript/gi framework? I'm fine with React already, why do I need this?"),"\n"),"\n",l.createElement(n.p,null,"Million works with React. Million makes creating web apps just as easy (It's just wrapping a ",l.createElement(n.a,{href:"https://reactjs.org/"},"React")," component!), but with faster rendering and loading speeds. By using a fine-tuned, optimized virtual DOM, Million.js reduces the overhead of React."),"\n"),"\n",l.createElement(n.p,null,"실제 렌더링 속도는 ",l.createElement(n.a,{href:"https://krausest.github.io/js-framework-benchmark/2023/table_chrome_112.0.5615.49.html"},"krausest/js-framework-benchmark")," 벤치마크를 참조해보면 확연하게 차이가 나는 걸 확인할 수 있다."),"\n",l.createElement("figure",null,l.createElement("img",{src:"/million-js/js-framework-benchmark.png",width:"400"})),"\n",l.createElement(n.h1,null,"어떻게 성능 최적화를 이끌어냈을까?"),"\n",l.createElement(n.p,null,"리액트는 잘 알려진 것처럼 virtual DOM 데이터와 diff 알고리즘으로 reconciliation 과정을 거쳐 화면을 수정한다. 그리고 이 과정은 ",l.createElement(n.code,null,"n"),"개의 node가 있는 트리에 대해 ",l.createElement(n.code,null,"O(n)")," 복잡도를 가지게 된다. (",l.createElement(n.a,{href:"https://ko.legacy.reactjs.org/docs/reconciliation.html"},"React Reconciliation document"),")"),"\n",l.createElement(n.p,null,"node가 많아질수록 diff 작업이 오래 걸리기 때문에 diff 과정에서 병목 현상이 발생하는 건 리액트 개발자라면 한 번쯤 격어봤을 것이다."),"\n",l.createElement("figure",null,l.createElement("img",{src:"/million-js/reconciliation.png"})),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Million.js"),"는 reconciliation을 사용하지 않기 때문에 tree를 렌더마다 재생성하지도 않고 node에 대한 diff 알고리즘도 사용하지 않는다."),"\n",l.createElement(n.p,null,"대신 보다 fine-grained reactivity framework(SolidJS, Qwik…)에 가깝게 필요한 부분만 update 하는데 이를 위해 정적 분석(Static Analysis)과 더티 체킹(Dirty Checking)을 사용한다."),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"컴포넌트를 정적 분석해 JSX tree의 변경될 수 있는 부분(",l.createElement("b",null,"dynamic part"),"), 즉 ",l.createElement(n.code,null,"{expression}"),"의 tree 내 위치와 데이터 및 관련 정보를 수집해 저장한다. (해당 데이터를 ",l.createElement("b",null,'"Edit Map"'),"이라 부른다)"),"\n",l.createElement(n.li,null,"컴포넌트가 update 되면 Edit Map을 통해 데이터를 이전과 비교(",l.createElement("b",null,"Dirty Checking"),")함으로써 변경된 부분만 DOM 업데이트를 진행한다."),"\n"),"\n",l.createElement(n.p,null,"위 처리 과정은 JSX tree에 expression이 m개 존재할 때 ",l.createElement(n.code,null,"O(m)"),"의 복잡도를 가지며 ",l.createElement("ins",null,"node 개수에 영향을 받지 않고 update 처리를 할 수 있다.")),"\n",l.createElement("figure",null,l.createElement("img",{src:"/million-js/millionjs.png"})),"\n",l.createElement(n.h1,null,"어떻게 구현했을까?"),"\n",l.createElement(n.p,null,"접근법을 보면 어떻게 구현해서 React에 embed 했을지 궁금할 수밖에 없다. 내부 구현은 3가지 영역으로 나뉘어져 있다."),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"Block Virtual DOM"),"\n",l.createElement(n.li,null,"Compiler"),"\n",l.createElement(n.li,null,"React HOC"),"\n"),"\n",l.createElement(n.h2,null,"Block Virtual DOM"),"\n",l.createElement(n.p,null,"Million.js가 사용하는 virtual DOM 시스템은 Block Virtual DOM이라 부르는데, 기존 virtual DOM들과는 다른 접근 방식을 가지고 있다."),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"컴포넌트를 관리하기 위해 block이라는 단위를 사용하며, 컴포넌트의 노드를 static하게 관리한다. 이를 위해 컴포넌트를 static node로 미리 생성하며, 이 과정에서 dynamic part는 Edit Map에 저장된다."),"\n",l.createElement(n.li,null,"이후 update가 있을 때 Edit Map의 데이터만 비교하는 방식으로 빠른 렌더링 속도를 보장해 준다."),"\n"),"\n",l.createElement(n.p,null,"아래는 약간 변형한 실제 소스이다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"const PLACEHOLDER_SYMBOL = Symbol('PLACEHOLDER_SYMBOL');\nconst PLACEHOLDER_PROXY = new Proxy({}, {\n  get(_, key) {\n    return { [PLACEHOLDER_SYMBOL]: key };\n  }\n});\n\nconst createBlock = (component, unwrap) => {\n  const velement = component(PLACEHOLDER_PROXY); // 1. props 대신 PLACEHOLDER Proxy를 넘겨서 element tree를 미리 생성한다.\n  const edits = []; // Edit Map\n\n  const root = stringToDOM(renderToTemplate(  // 2. velement를 static DOM node로 치환한다. 이 과정에서 PLACEHOLDER 데이터가 쓰이는 곳은 Edit Map에 저장된다.\n    unwrap ? unwrap(velement) : velement,\n    edits\n  ));\n\n  return (props) => new Block( // 3. 실제 데이터 props를 전달받아 Block instance를 생성한다.\n    root,\n    edits,\n    props,\n  );\n};\n\nconst block = createBlock((props) => (\n  <div id={props.id} onClick={props.onClick}>\n    Hello, {props.name} - ({props.cnt})\n  </div>\n));\n")),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"실제 데이터 대신 미리 ",l.createElement(n.code,null,"PLACEHOLDER")," Proxy를 넘겨 ",l.createElement(n.code,null,"velement"),"를 생성한다. 생성 과정에서 props data를 사용하는 dynamic part는 ",l.createElement(n.code,null,"PLACEHOLDER")," 값이 들어가게 되어 다른 데이터와 구분이 가능해진다. 결괏값은 아래처럼 생성될 것이다."),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"const velement = {\n  type: 'div',\n  props: {\n    id: { [PLACEHOLDER_SYMBOL]: 'id' },\n    onClick: { [PLACEHOLDER_SYMBOL]: 'onClick' },\n    children: [\n      'Hello, ',\n      { [PLACEHOLDER_SYMBOL]: 'name' },\n      ' - (',\n      {[PLACEHOLDER_SYMBOL]: 'cnt' },\n      ')',\n    ],\n  },\n};\n")),"\n",l.createElement(n.ol,{start:"2"},"\n",l.createElement(n.li,null,l.createElement(n.code,null,"velement"),"를 node로 치환할 때 ",l.createElement(n.code,null,"PLACEHOLDER"),"를 체크해 edits에 저장한다. edits와 root는 아래와 같을 값 형태를 가지고 있다."),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-javascript"},"const edits = [\n  {\n    path: [],\n    edit: [\n      { // id attr\n        type: AttributeFlag, // 어떤 type인지를 나타낸다. Child, Attribute, Event, StyleAttribute, SvgAttribute, Block\n        name: 'id', // attribute, event의 name\n        hole: 'id', // data key\n        index: null, // child일 경우 자신의 index 값\n        patch: null, // event listener patch 전용 필드\n      },\n      { // click event\n        type: EventFlag,\n        name: 'Click',\n        hole: 'onClick',\n        index: null,\n        patch: null,\n      },\n      { // 1번 index child에 name\n        type: ChildFlag,\n        name: null,\n        hole: 'name',\n        index: 1,\n        patch: null,\n      },\n      { // 3번 index child에 cnt\n        type: ChildFlag,\n        name: null,\n        hole: 'cnt',\n        index: 3,\n        patch: null,\n      },\n    ],\n    initial: [],\n  },\n];\n\nroot = <div>Hello, </div>; // Edit Map 데이터들은 바로 반영되지 않는다.\n")),"\n",l.createElement(n.p,null,"edits에서 ",l.createElement(n.code,null,"edit"),"은 ",l.createElement(n.code,null,"PLACEHOLDER"),"들에 대한 정보가 저장되며 ",l.createElement(n.code,null,"initial"),"은 ",l.createElement(n.code,null,"PLACEHOLDER"),"가 아니지만 static template으로 치환이 안 되는 데이터(event callback, 다른 block component)를 initial에 저장해 뒀다가 mount 단계에서 추가해 준다."),"\n",l.createElement(n.ol,{start:"3"},"\n",l.createElement(n.li,null,"실제 데이터를 전달받아 Block instance를 생성하게 되면 이제 DOM을 렌더링할 준비가 끝난다. 아래는 block을 활용한 실제 예시 코드이다."),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"let cnt = 0;\nconst block = createBlock((props) => (\n  <div id={props.id} onClick={props.onClick}>\n    Hello, {props.name} - ({props.cnt})\n  </div>\n));\n\nconst onClick = () => {\n  ... // update 코드가 들어갈 부분\n};\n\n// Block instance 생성\nconst app = block({\n  id: 'first',\n  name: 'pyjun01',\n  cnt,\n  onClick,\n});\n\napp.mount(document.querySelector('#app')); // Edit Map을 순회하며 PLACEHOLDER를 props 데이터(= { id: 'first', name: 'pyjun01', cnt: 0, onClick: fn })로 채워준다.\n")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"mount를 호출하면 생성된 root에 dynamic part가 채워지며 ",l.createElement(n.code,null,"#app"),"에 mount 된다. 아래는 mount method의 일부이다."),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"  // root가 <div>Hello, </div>에서 <div id='first'>Hello, pyjun01 - (0)</div>로 변경된다.\n\n  mount(parent) { // root를 insert할 대상 node\n    const root = this.root.cloneNode(true);\n\n    ...\n\n    for (let i = 0, j = this.edits.length; i < j; ++i) { // (1) Edit Map을 순회한다.\n      const current = this.edits[i];\n      const el = getCurrentElement(current.path, root, this.cache, i); // (2) path를 통해 대상 element를 가져온다. path 값이 없으면 root가 대상 element이다.\n  \n      for (let k = 0, l = current.edit.length; k < l; ++k) { // (3) edit을 순회하며 값들을 추가한다.\n        const edit = current.edit[k];\n        const value = this.data[edit.hole]; // PLACEHOLDER의 실제 데이터\n  \n        if (edit.type & ChildFlag) { // children을 insert한다. name 값이 여기서 추가된다.\n          ...\n          insertText(el, String(value), edit.index); // el.insertBefore(...) \n        } else if (edit.type & AttributeFlag) { // attribute를 설정한다. id attr이 여기서 설정된다.\n          setAttribute(el, edit.name, value); // el.setAttribute(...);\n        } else if (edit.type & EventFlag) { // event listener를 설정한다. onClick이 여기서 설정된다.\n          const patch = createEventListener(el, edit.name, value); // el.addEventListener()\n          edit.patch = patch; // Edit Map에 patch 필드를 설정한다.\n        } ...\n      }\n    }\n\n    ...\n  \n    if (parent) {\n      parent.insertBefore(root, null); // append\n    }\n  }\n")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"(1) Edit Map을 순회한다."),"\n",l.createElement(n.li,null,"(2) path(= [0,1,2]일 경우 ",l.createElement(n.code,null,"> :nth-child(1) > :nth-child(2) > :nth-child(3)"),")를 통해 대상 element를 가져온다."),"\n",l.createElement(n.li,null,"(3) edit을 순회하며 child, attribute(style, eventListener, ...etc)를 추가해 준다."),"\n"),"\n",l.createElement(n.p,null,"mount된 DOM을 update 하려면 patch가 필요하다. ",l.createElement(n.code,null,"onClick"),"에 patch 로직을 추가하자."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"let cnt = 0;\nconst block = createBlock((props) => (\n  <div id={props.id} onClick={props.onClick}>\n    Hello, {props.name} - ({props.cnt})\n  </div>\n));\n\nconst onClick = () => {\n++    cnt++;\n++\n++    const newApp = block({ // 새로운 데이터로 block을 새로 생성한다.\n++      id: 'clicked',\n++      name: 'pyjun01',\n++      cnt,\n++      onClick\n++    });\n++\n++    app.patch(newApp); // 생성한 block을 patch 하면 Edit Map을 순회하며 데이터를 비교해 변경을 반영한다.\n};\n\nconst app = block({\n  id: 'first',\n  name: 'pyjun01',\n  cnt,\n  onClick,\n});\n\napp.mount(document.querySelector('#app'));\n")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"patch는 ",l.createElement(n.code,null,"newValue"),"(= 새로운 block의 data)와 ",l.createElement(n.code,null,"oldValue"),"(= 기존 block의 data)를 비교하며 변경된 부분만 ",l.createElement(n.code,null,"newValue로")," 치환한다."),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"patch(newBlock) {\n  const root = this.root;\n  if (!newBlock.data) return root;\n\n  const props = this.data;\n  this.data = newBlock.data;\n\n  for (let i = 0, j = this.edits.length; i < j; ++i) { // 1. mount와 동일하게 Edit Map을 순회한다.\n    ...\n    for (let k = 0, l = current.edit.length; k < l; ++k) {\n      const edit = current.edit[k];\n      const oldValue = props[edit.hole];\n      const newValue = newBlock.data[edit.h];\n\n      if (newValue === oldValue) continue; // 2. 비교해서 같으면 변경하지 않는다.\n\n      ...\n\n      // 3.\n      if (edit.type & EventFlag) {\n        edit.patch(newValue); // mount에서 설정한 patch\n      } else if (edit.type & ChildFlag) {\n        ...\n        setText(el, String(newValue), edit.index);\n      } else if (edit.type & AttributeFlag) {\n        setAttribute(el, edit.name, newValue);\n      } ...\n    }\n  }\n\n  return root;\n}\n")),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"mount와 동일하게 Edit Map을 순회한다."),"\n",l.createElement(n.li,null,"value가 같다면 변경하지 않고 넘어간다."),"\n",l.createElement(n.li,null,"바뀐 부분이 있다면 newValue로 변경해 준다."),"\n"),"\n",l.createElement(n.p,null,"Example"),"\n",l.createElement(r,{codeSandboxId:"block-demo-9h3pil"}),"\n",l.createElement(n.h2,null,"Compiler"),"\n",l.createElement(n.p,null,"Million.js는 이전에 설명한 것처럼 JSX tree의 expression 값 변경을 체크하는데 이는 expression들이 Block DOM에 넘기는 데이터(= props)가 된다는 뜻이다. 그러기 위해서 expression을 props로 넘기도록 구조를 수정해야 하고 이를 위해 compiler의 도움이 필요하다."),"\n",l.createElement(n.p,null,"compiler는 block으로 감싸져 있는 컴포넌트를 분석해 두 개로 분리한다."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"(1) return JSX tree 그대로 return 하며 expression 값들만 props로 받는 stateless component + 해당 컴포넌트를 block HOC으로 감싼 Block(= ",l.createElement(n.code,null,"block(stateless component)"),")"),"\n",l.createElement(n.li,null,"(2) Block을 return 하고 나머지는 그대로인 원본 컴포넌트"),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"/*** 원본 컴포넌트 ***/\nfunction App(props) {\n  const [cnt, setCnt] = useState(0);\n\n  return (\n    <div id={props.id} onClick={() => setCnt(cnt+1)}>\n      Hello, {props.name} - ({cnt})\n    </div>\n  );\n}\nconst AppBlock = block(App);\n\n/*** 컴파일된 컴포넌트 ***/\nfunction BlockUI({\n  _$2, // {variable} 형태가 아니라면 key를 자동으로 생성해 준다.\n  _$3,\n  _$4,\n  cnt\n}) {\n  return (\n    <div id={_$2} onClick={_$3}>\n      Hello, {_$4} - ({cnt})\n    </div>\n  );\n}\nconst BlockComponent = block(BlockUI); // (1)\n\nfunction App(props) { // (2)\n  const [cnt, setCnt] = useState(0);\n\n  return BlockComponent({\n    _$2: props.id,\n    _$3: () => setCnt(cnt+1),\n    _$4: props.name,\n    cnt,\n  });\n}\nconst AppBlock = App;\n")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"props가 변수가 아닐 때는 auto-increment로 key를 생성한다."),"\n",l.createElement(n.li,null,l.createElement(n.code,null,"BlockComponent"),"에 사용된 ",l.createElement(n.code,null,"block")," 함수는 React HOC 함수이다."),"\n"),"\n",l.createElement(n.p,null,"컴포넌트가 분리됐다면 이제 HOC 함수 내에서 Block Virtual DOM과 React component를 적절히 조화시키면 된다."),"\n",l.createElement(n.h2,null,"React HOC"),"\n",l.createElement(n.p,null,"React HOC는 다음과 같은 작업을 진행한다."),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"React reconciliation 대신 Block Virtual DOM을 사용해야 하므로 컴포넌트 내부에서는 JSX tree를 return 하는 것이 아니라 Block instance로 생성한다. (block의 mount 대상이 될 적절한 temp tag는 react를 통한 렌더링이 필요하다)"),"\n",l.createElement(n.li,null,l.createElement(n.code,null,"useEffect"),"를 통해 컴포넌트 mount시 block을 temp tag에 mount 시킨다."),"\n",l.createElement(n.li,null,"이후 update가 발생하면 patch를 호출해 변경된 데이터를 DOM에 반영한다."),"\n"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-jsx"},"const css = 'million-block, million-fragment { display: contents }'; // 1. temp tag용 style 설정\nconst style = document.createElement('style');\nObject.assign(style, {\n  type: 'text/css',\n  innerHTML: css,\n})\ndocument.head.appendChild(style);\n\nexport const block = (\n  fn,\n  options = {},\n) => {\n  const block = createBlock(fn, unwrap);\n\n  return function MillionBlock(props) {\n    const ref = useRef(null); // tmep tag DOM ref\n    const patch = useRef(null); // patch function\n\n    patch.current?.(props); // 3. patch 호출\n\n    useEffect(() => {\n      const currentBlock = block(props, props.key);\n\n      if (ref.current) {\n        currentBlock.mount(ref.current, null); // 2. block을 mount 한다.\n\n        patch.current = (props) => { // patch ref 값을 설정한다.\n          currentBlock.patch(block(props));\n        };\n      }\n\n      return () => {\n        currentBlock.remove(); // 4. remove\n      };\n    }, []);\n\n    return <million-block ref={ref} />; // million-block이라는 tag를 container로 사용한다.\n  }\n};\n")),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,l.createElement(n.code,null,"display: contents;")," style이 생소할 수 있는데 대상 node를 마치 DOM에 없는 것처럼 처리해 준다. (= contents의 자식이 contents를 무시하고 조부모를 부모로 인식한다)"),"\n",l.createElement(n.li,null,"컴포넌트 mount 이후 ",l.createElement(n.code,null,"useEffect"),"가 호출되면 block.mount를 호출해 렌더링한다."),"\n",l.createElement(n.li,null,"컴포넌트 최초 호출에서는 patch ref가 initial value(= null)이므로 호출이 안 되고 이후 컴포넌트가 update 될 때 ",l.createElement(n.code,null,"useEffect")," 내부에서 할당한 patch 함수가 호출되어 업데이트된다."),"\n",l.createElement(n.li,null,"컴포넌트가 unmount 되어 destructor가 호출되면 block.remove를 호출해 DOM node를 제거한다."),"\n"),"\n",l.createElement(n.h1,null,"결론"),"\n",l.createElement(n.p,null,"Million.js의 핵심적인 코드 부분을 살펴보았다. 코드를 살펴보면서 느꼈을 수 있지만 당연히 모든 곳에 적용한다고 성능 향상이 보장되는 것은 아니며 제약사항이 여럿 존재해 할 수도 없다."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"component composition 불가"),"\n",l.createElement(n.li,null,"component early return 불가"),"\n",l.createElement(n.li,null,"expression에서 JSX(= ReactElement) 사용 불가"),"\n",l.createElement(n.li,null,"spread attribute 사용 불가"),"\n"),"\n",l.createElement(n.p,null,"(글 업로드 날 기준으로 최신 버전에서는 위 제약사항 중 몇몇이 해결됐다)"),"\n",l.createElement(n.p,null,"아직 분명한 한계가 존재하지만, 특정 케이스(static 요소)에서는 높은 활용도를 가지고 있고 lib의 개선도 계속되고 있으니 많은 변경이 필요한 프로젝트에서 채택을 고려해볼만한 가치가 있다."),"\n",l.createElement(n.h1,null,"부록"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"\n",l.createElement("a",{href:"https://twitter.com/aidenybai/status/1647005716350406656",target:"_blank"},"Aiden Bai의 Million.js React 비교 트윗"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement("a",{href:"https://github.com/ged-odoo/blockdom",target:"_blank"},"blockdom"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement("a",{href:"https://million.dev/blog/virtual-dom",target:"_blank"},"Virtual DOM: Back in Block"),"\n"),"\n"))}var r=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,c.RP)(),e.components);return n?l.createElement(n,e,l.createElement(a,e)):a(e)};function o(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}var i=t(1510),m=t(7717),u=t(6089),s=t(1042),p=t(5242),d=t(7271),E=t(5109),h=t(1869);const k={Tweet:m.Yk,CodeSandbox:m.dH},g=i.default.div.withConfig({displayName:"mdxparent__File__name__Container",componentId:"sc-15llss4-0"})(["padding:32px 0;> h2{margin:0;font-size:3rem;line-height:3.75rem;letter-spacing:-0.0625rem;font-weight:100;font-family:Georgia,Times,serif;}> .date{margin:32px 0 56px;text-align:right;}img{max-width:100%;}figure{margin:1.5rem 0;img{display:block;margin:0 auto;}figcaption{font-size:0.875rem;color:#757575;text-align:center;}}@media (max-width:680px){> .date{font-size:1.3rem;}> .content{font-size:1.5rem;line-height:2.25rem;}}"]);function f(e){let{data:n,children:t}=e;return l.createElement(u.A,{pageTitle:n.mdx.frontmatter.title},l.createElement(s.A,{title:n.mdx.frontmatter.title,description:n.mdx.frontmatter.preview,slug:n.mdx.frontmatter.slug}),l.createElement(g,null,l.createElement("h2",null,n.mdx.frontmatter.title),l.createElement("p",{className:"date"},n.mdx.frontmatter.date),l.createElement("div",{className:"content"},l.createElement(c.xA,{components:Object.assign({pre:p.A,a:E.A,h1:d.H1,h2:d.H2,h3:d.H3,h4:d.H4,h5:d.H5,h6:d.H6,TableOfContents:e=>l.createElement(h.A,Object.assign({},e,{headings:n.mdx.headings}))},k)},t))),l.createElement("img",{src:"https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fpyjun01.github.io/v/"+n.mdx.frontmatter.slug+"&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=hits&edge_flat=false",style:{opacity:0}}))}function b(e){return l.createElement(f,e,l.createElement(r,e))}}}]);
//# sourceMappingURL=component---src-pages-v-mdx-parent-file-name-tsx-content-file-path-src-blog-million-js-mdx-b7d4be2847d4c6698e2d.js.map